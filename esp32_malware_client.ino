/*
 * ESP32 IoT Malware Detection Client
 * Connects to cloud ML API for real-time threat detection
 * 
 * Hardware: ESP32 DevKit or similar
 * Libraries needed: WiFi, HTTPClient, ArduinoJson
 */

#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <WiFiClientSecure.h>

// WiFi Configuration
const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";

// API Configuration
const char* api_server = "YOUR_API_SERVER_URL";  // e.g., "http://your-server.com:5000"
const char* api_endpoint = "/predict/simple";
const int api_timeout = 10000;  // 10 seconds timeout

// LED Pins for status indication
const int LED_SAFE = 2;      // Green LED - Safe traffic
const int LED_THREAT = 4;    // Red LED - Threat detected
const int LED_STATUS = 5;    // Blue LED - System status

// Network monitoring variables
unsigned long lastCheck = 0;
const unsigned long checkInterval = 30000;  // Check every 30 seconds
int connectionCount = 0;
bool systemActive = true;

void setup() {
  Serial.begin(115200);
  
  // Initialize LEDs
  pinMode(LED_SAFE, OUTPUT);
  pinMode(LED_THREAT, OUTPUT);
  pinMode(LED_STATUS, OUTPUT);
  
  // Startup LED sequence
  startupSequence();
  
  Serial.println("ğŸ”’ ESP32 IoT Malware Detection Client");
  Serial.println("=====================================");
  
  // Connect to WiFi
  connectToWiFi();
  
  // Test API connection
  testAPIConnection();
  
  Serial.println("âœ… System ready for malware detection");
  digitalWrite(LED_STATUS, HIGH);
}

void loop() {
  // Check WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("âš ï¸  WiFi disconnected, reconnecting...");
    digitalWrite(LED_STATUS, LOW);
    connectToWiFi();
    return;
  }
  
  // Perform periodic security check
  if (millis() - lastCheck >= checkInterval) {
    performSecurityCheck();
    lastCheck = millis();
  }
  
  // Monitor network activity (simulated)
  monitorNetworkActivity();
  
  delay(1000);  // 1 second delay
}

void connectToWiFi() {
  Serial.print("ğŸŒ Connecting to WiFi: ");
  Serial.println(ssid);
  
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
    
    // Blink status LED while connecting
    digitalWrite(LED_STATUS, !digitalRead(LED_STATUS));
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println();
    Serial.println("âœ… WiFi connected successfully!");
    Serial.print("ğŸ“¡ IP Address: ");
    Serial.println(WiFi.localIP());
    digitalWrite(LED_STATUS, HIGH);
  } else {
    Serial.println();
    Serial.println("âŒ WiFi connection failed!");
    digitalWrite(LED_STATUS, LOW);
  }
}

void testAPIConnection() {
  Serial.println("ğŸ” Testing API connection...");
  
  HTTPClient http;
  http.begin(String(api_server) + "/health");
  http.setTimeout(api_timeout);
  
  int httpCode = http.GET();
  
  if (httpCode == 200) {
    String response = http.getString();
    Serial.println("âœ… API server is online");
    Serial.println("ğŸ“Š Server response: " + response);
  } else {
    Serial.println("âŒ API server connection failed");
    Serial.println("ğŸ”§ HTTP Code: " + String(httpCode));
  }
  
  http.end();
}

void performSecurityCheck() {
  Serial.println("\nğŸ” Performing security check...");
  
  // Simulate network traffic data (replace with real network monitoring)
  NetworkData traffic = generateNetworkData();
  
  // Send to ML API for analysis
  ThreatAnalysis result = analyzeTraffic(traffic);
  
  // Handle the result
  handleThreatResult(result);
  
  connectionCount++;
}

NetworkData generateNetworkData() {
  NetworkData data;
  
  // Simulate different types of network traffic
  int trafficType = random(0, 4);
  
  switch (trafficType) {
    case 0: // Normal web traffic
      data.id_orig_p = 443;
      data.id_resp_p = 80;
      data.duration = 0.5;
      data.orig_bytes = 1500;
      data.resp_bytes = 8000;
      data.orig_pkts = 10;
      data.resp_pkts = 15;
      data.orig_ip_bytes = 1500;
      data.resp_ip_bytes = 8000;
      Serial.println("ğŸ“Š Simulating: Normal web traffic");
      break;
      
    case 1: // Suspicious port scan
      data.id_orig_p = 17576;
      data.id_resp_p = 8081;
      data.duration = 0.000002;
      data.orig_bytes = 0;
      data.resp_bytes = 0;
      data.orig_pkts = 2;
      data.resp_pkts = 0;
      data.orig_ip_bytes = 80;
      data.resp_ip_bytes = 0;
      Serial.println("ğŸš¨ Simulating: Suspicious port scan");
      break;
      
    case 2: // Potential DDoS
      data.id_orig_p = random(1024, 65535);
      data.id_resp_p = 80;
      data.duration = 0.001;
      data.orig_bytes = 50;
      data.resp_bytes = 0;
      data.orig_pkts = 1;
      data.resp_pkts = 0;
      data.orig_ip_bytes = 50;
      data.resp_ip_bytes = 0;
      Serial.println("âš¡ Simulating: Potential DDoS attack");
      break;
      
    case 3: // IoT device communication
      data.id_orig_p = random(1024, 5000);
      data.id_resp_p = random(80, 443);
      data.duration = random(1, 100) / 100.0;
      data.orig_bytes = random(100, 1000);
      data.resp_bytes = random(50, 500);
      data.orig_pkts = random(1, 10);
      data.resp_pkts = random(1, 8);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("ğŸ  Simulating: IoT device communication");
      break;
  }
  
  data.missed_bytes = 0;  // Usually 0 for simulated data
  
  return data;
}

ThreatAnalysis analyzeTraffic(NetworkData data) {
  ThreatAnalysis result;
  result.is_malicious = false;
  result.confidence = 0.0;
  result.threat_level = "MINIMAL";
  result.recommendation = "ALLOW_NORMAL_OPERATION";
  result.error = "";
  
  HTTPClient http;
  http.begin(String(api_server) + api_endpoint);
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(api_timeout);
  
  // Create JSON payload
  DynamicJsonDocument doc(1024);
  doc["id_orig_p"] = data.id_orig_p;
  doc["id_resp_p"] = data.id_resp_p;
  doc["duration"] = data.duration;
  doc["orig_bytes"] = data.orig_bytes;
  doc["resp_bytes"] = data.resp_bytes;
  doc["missed_bytes"] = data.missed_bytes;
  doc["orig_pkts"] = data.orig_pkts;
  doc["orig_ip_bytes"] = data.orig_ip_bytes;
  doc["resp_pkts"] = data.resp_pkts;
  doc["resp_ip_bytes"] = data.resp_ip_bytes;
  
  String jsonString;
  serializeJson(doc, jsonString);
  
  Serial.println("ğŸ“¤ Sending to ML API: " + jsonString);
  
  int httpCode = http.POST(jsonString);
  
  if (httpCode == 200) {
    String response = http.getString();
    Serial.println("ğŸ“¥ API Response: " + response);
    
    // Parse JSON response
    DynamicJsonDocument responseDoc(1024);
    deserializeJson(responseDoc, response);
    
    result.is_malicious = responseDoc["is_malicious"];
    result.confidence = responseDoc["confidence"];
    result.threat_level = responseDoc["threat_level"].as<String>();
    result.recommendation = responseDoc["recommendation"].as<String>();
    
  } else {
    Serial.println("âŒ API request failed");
    Serial.println("ğŸ”§ HTTP Code: " + String(httpCode));
    result.error = "API_ERROR";
  }
  
  http.end();
  return result;
}

void handleThreatResult(ThreatAnalysis result) {
  Serial.println("\nğŸ“‹ THREAT ANALYSIS RESULT:");
  Serial.println("================================");
  
  if (result.error != "") {
    Serial.println("âŒ Error: " + result.error);
    blinkLED(LED_STATUS, 3, 200);
    return;
  }
  
  Serial.println("ğŸ¯ Malicious: " + String(result.is_malicious ? "YES" : "NO"));
  Serial.println("ğŸ“Š Confidence: " + String(result.confidence * 100, 1) + "%");
  Serial.println("âš ï¸  Threat Level: " + result.threat_level);
  Serial.println("ğŸ’¡ Recommendation: " + result.recommendation);
  
  // Visual indication
  if (result.is_malicious) {
    Serial.println("ğŸš¨ THREAT DETECTED - Taking protective action!");
    
    // Red LED for threat
    digitalWrite(LED_SAFE, LOW);
    digitalWrite(LED_THREAT, HIGH);
    
    // Alert pattern
    for (int i = 0; i < 5; i++) {
      digitalWrite(LED_THREAT, LOW);
      delay(100);
      digitalWrite(LED_THREAT, HIGH);
      delay(100);
    }
    
    // Take protective action based on recommendation
    if (result.recommendation == "BLOCK_IMMEDIATELY") {
      Serial.println("ğŸ›¡ï¸  BLOCKING CONNECTION IMMEDIATELY");
      // Add your blocking logic here
    } else if (result.recommendation == "INVESTIGATE_AND_MONITOR") {
      Serial.println("ğŸ” INVESTIGATING AND MONITORING");
      // Add your monitoring logic here
    }
    
  } else {
    Serial.println("âœ… Traffic appears safe");
    
    // Green LED for safe
    digitalWrite(LED_THREAT, LOW);
    digitalWrite(LED_SAFE, HIGH);
    delay(1000);
    digitalWrite(LED_SAFE, LOW);
  }
  
  Serial.println("================================\n");
}

void monitorNetworkActivity() {
  // Simulate network activity monitoring
  // In a real implementation, you would:
  // 1. Monitor actual network packets
  // 2. Extract flow features
  // 3. Send suspicious flows to the API
  
  static unsigned long lastActivity = 0;
  
  if (millis() - lastActivity > 5000) {  // Every 5 seconds
    // Simulate random network activity
    if (random(0, 100) < 10) {  // 10% chance of activity
      Serial.println("ğŸ“¡ Network activity detected");
      digitalWrite(LED_STATUS, LOW);
      delay(50);
      digitalWrite(LED_STATUS, HIGH);
    }
    lastActivity = millis();
  }
}

void startupSequence() {
  Serial.println("ğŸš€ Starting up...");
  
  // LED startup sequence
  for (int i = 0; i < 3; i++) {
    digitalWrite(LED_SAFE, HIGH);
    delay(200);
    digitalWrite(LED_SAFE, LOW);
    digitalWrite(LED_THREAT, HIGH);
    delay(200);
    digitalWrite(LED_THREAT, LOW);
    digitalWrite(LED_STATUS, HIGH);
    delay(200);
    digitalWrite(LED_STATUS, LOW);
  }
}

void blinkLED(int pin, int times, int delayMs) {
  for (int i = 0; i < times; i++) {
    digitalWrite(pin, HIGH);
    delay(delayMs);
    digitalWrite(pin, LOW);
    delay(delayMs);
  }
}

// Data structures
struct NetworkData {
  int id_orig_p;
  int id_resp_p;
  float duration;
  int orig_bytes;
  int resp_bytes;
  int missed_bytes;
  int orig_pkts;
  int orig_ip_bytes;
  int resp_pkts;
  int resp_ip_bytes;
};

struct ThreatAnalysis {
  bool is_malicious;
  float confidence;
  String threat_level;
  String recommendation;
  String error;
};