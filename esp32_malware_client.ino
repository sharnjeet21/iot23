

#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <WiFiClientSecure.h>

// Struct definitions must come before use
struct NetworkData {
  int id_orig_p;
  int id_resp_p;
  float duration;
  int orig_bytes;
  int resp_bytes;
  int missed_bytes;
  int orig_pkts;
  int orig_ip_bytes;
  int resp_pkts;
  int resp_ip_bytes;
};

struct ThreatAnalysis {
  bool is_malicious;
  float confidence;
  String threat_level;
  String recommendation;
  String error;
};

const char* ssid = "Redmi";
const char* password = "12345678";

const char* api_server = "http://10.128.138.251:8080";
const char* api_endpoint = "/predict/simple";
const int api_timeout = 30000;  // Increased to 30 seconds

// LED Pins for D2, D4, D5
const int LED_SAFE = 2;      // D2 - Green LED (safe traffic)
const int LED_THREAT = 4;    // D4 - Red LED (threat detected)
const int LED_STATUS = 5;    // D5 - Blue/Yellow LED (status)

unsigned long lastCheck = 0;
const unsigned long checkInterval = 30000;
int connectionCount = 0;
bool systemActive = true;

void setup() {
  Serial.begin(115200);
  delay(1000);  // Give serial time to initialize
  
  pinMode(LED_SAFE, OUTPUT);
  pinMode(LED_THREAT, OUTPUT);
  pinMode(LED_STATUS, OUTPUT);
  
  startupSequence();
  
  Serial.println("\n\n");
  Serial.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘  ESP32 IoT Malware Detection Client   â•‘");
  Serial.println("â•‘      3-LED Indicator System Active     â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  Serial.println();
  
  connectToWiFi();
  
  testAPIConnection();
  
  Serial.println("\nâœ… System ready for malware detection");
  Serial.println("ğŸ’¡ LED Indicators:");
  Serial.println("   â€¢ Green (D2) = Safe traffic");
  Serial.println("   â€¢ Red (D4) = Threat detected");
  Serial.println("   â€¢ Blue (D5) = Status/Activity");
  Serial.println();
  digitalWrite(LED_STATUS, HIGH);
  delay(500);
  digitalWrite(LED_STATUS, LOW);
}

void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("\nâš ï¸  WiFi disconnected, reconnecting...");
    digitalWrite(LED_STATUS, LOW);
    connectToWiFi();
    return;
  }
  
  if (millis() - lastCheck >= checkInterval) {
    Serial.println("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Serial.println("ğŸ• Check #" + String(connectionCount + 1) + " - " + String(millis()/1000) + "s uptime");
    performSecurityCheck();
    lastCheck = millis();
  }
  
  monitorNetworkActivity();
  
  delay(1000);
}

void connectToWiFi() {
  Serial.println("ğŸŒ Connecting to WiFi: " + String(ssid));
  Serial.print("   ");
  
  WiFi.begin(ssid, password);
  
  // Disable WiFi power saving for better connectivity
  WiFi.setSleep(false);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
    
    digitalWrite(LED_STATUS, !digitalRead(LED_STATUS));
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println(" Connected!");
    Serial.println("âœ… WiFi connected successfully!");
    Serial.println("ğŸ“¡ ESP32 IP Address: " + WiFi.localIP().toString());
    Serial.println("ğŸŒ Subnet Mask: " + WiFi.subnetMask().toString());
    Serial.println("ğŸšª Gateway IP: " + WiFi.gatewayIP().toString());
    Serial.println("ğŸ” DNS Server: " + WiFi.dnsIP().toString());
    Serial.println("ğŸ“¶ Signal Strength: " + String(WiFi.RSSI()) + " dBm");
    Serial.println("ğŸ–¥ï¸  Server IP: " + String(api_server));
    digitalWrite(LED_STATUS, HIGH);
    delay(200);
    digitalWrite(LED_STATUS, LOW);
  } else {
    Serial.println(" Failed!");
    Serial.println("âŒ WiFi connection failed after " + String(attempts) + " attempts");
    digitalWrite(LED_STATUS, LOW);
  }
}

void testAPIConnection() {
  Serial.println("\nğŸ” Testing API connection...");
  Serial.println("   Target: " + String(api_server) + "/health");
  Serial.println("   ESP32 IP: " + WiFi.localIP().toString());
  Serial.println("   Gateway: " + WiFi.gatewayIP().toString());
  
  // Test basic connectivity first with multiple attempts
  Serial.println("ğŸŒ Testing basic connectivity...");
  bool tcpSuccess = false;
  
  for (int attempt = 1; attempt <= 5; attempt++) {
    Serial.println("   TCP Attempt " + String(attempt) + "/5...");
    WiFiClient client;
    client.setTimeout(15000); // 15 second timeout
    
    // Try to connect to the server
    if (client.connect("192.168.1.37", 8080)) {
      Serial.println("âœ… TCP connection successful on attempt " + String(attempt));
      
      // Send a simple HTTP request
      client.println("GET /health HTTP/1.1");
      client.println("Host: 192.168.1.37:8080");
      client.println("User-Agent: ESP32-MalwareDetector/1.0");
      client.println("Connection: close");
      client.println();
      
      // Wait for response
      unsigned long timeout = millis();
      while (client.available() == 0) {
        if (millis() - timeout > 10000) {
          Serial.println("â° Response timeout after 10s");
          break;
        }
        delay(100);
      }
      
      if (client.available()) {
        String response = "";
        while (client.available()) {
          response += client.readString();
        }
        Serial.println("ğŸ“„ HTTP Response received:");
        Serial.println(response.substring(0, 200) + "...");
      }
      
      client.stop();
      tcpSuccess = true;
      break;
    } else {
      Serial.println("âŒ TCP connection failed on attempt " + String(attempt));
      Serial.println("   Error details: Connection refused or timeout");
      delay(2000); // Wait 2 seconds between attempts
    }
  }
  
  if (!tcpSuccess) {
    Serial.println("ğŸ’¡ All TCP attempts failed - possible causes:");
    Serial.println("   â€¢ Server not accessible from ESP32");
    Serial.println("   â€¢ Firewall blocking connections");
    Serial.println("   â€¢ Network routing issues");
    Serial.println("   â€¢ AP isolation enabled on router");
    return;
  }
  
  // Now test HTTP client library
  Serial.println("ğŸŒ Testing HTTPClient library...");
  HTTPClient http;
  http.begin(String(api_server) + "/health");
  http.setTimeout(api_timeout);
  http.addHeader("User-Agent", "ESP32-MalwareDetector/1.0");
  
  unsigned long startTime = millis();
  int httpCode = http.GET();
  unsigned long responseTime = millis() - startTime;
  
  Serial.println("â±ï¸  HTTP Response time: " + String(responseTime) + "ms");
  Serial.println("ğŸ”§ HTTP Response Code: " + String(httpCode));
  
  if (httpCode == 200) {
    String response = http.getString();
    Serial.println("âœ… API server is ONLINE and responding");
    Serial.println("ğŸ“Š Response: " + response);
    
    // Success blink - status LED
    for(int i=0; i<3; i++) {
      digitalWrite(LED_STATUS, HIGH);
      delay(200);
      digitalWrite(LED_STATUS, LOW);
      delay(200);
    }
  } else if (httpCode > 0) {
    Serial.println("âŒ HTTP Error: " + String(httpCode));
    String response = http.getString();
    if (response.length() > 0) {
      Serial.println("ğŸ“„ Error Response: " + response);
    }
    
    // Error blink - status LED
    for(int i=0; i<5; i++) {
      digitalWrite(LED_STATUS, HIGH);
      delay(100);
      digitalWrite(LED_STATUS, LOW);
      delay(100);
    }
  } else {
    Serial.println("âŒ HTTPClient Error: " + String(httpCode));
    Serial.println("ğŸ’¡ Possible causes:");
    Serial.println("   â€¢ Connection timeout");
    Serial.println("   â€¢ DNS resolution failed");
    Serial.println("   â€¢ Network unreachable");
    
    // Error blink - status LED
    for(int i=0; i<5; i++) {
      digitalWrite(LED_STATUS, HIGH);
      delay(100);
      digitalWrite(LED_STATUS, LOW);
      delay(100);
    }
  }
  
  http.end();
}

void performSecurityCheck() {
  Serial.println("ğŸ” Performing security check...");
  
  // Status LED on during check
  digitalWrite(LED_STATUS, HIGH);
  
  NetworkData traffic = generateNetworkData();
  
  ThreatAnalysis result = analyzeTraffic(traffic);
  
  handleThreatResult(result);
  
  connectionCount++;
  
  // Status LED off after check
  digitalWrite(LED_STATUS, LOW);
}

NetworkData generateNetworkData() {
  NetworkData data;
  
  int trafficType = random(0, 12);  // Expanded to 12 different traffic types
  
  Serial.println("\nğŸ“¦ Generating Network Traffic Data:");
  
  switch (trafficType) {
    case 0:  // Normal HTTPS web traffic
      data.id_orig_p = 443;
      data.id_resp_p = 80;
      data.duration = random(300, 2000) / 1000.0;  // 0.3-2.0 seconds
      data.orig_bytes = random(1200, 2000);
      data.resp_bytes = random(5000, 12000);
      data.orig_pkts = random(8, 15);
      data.resp_pkts = random(12, 20);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("   Type: âœ… Normal HTTPS web traffic");
      Serial.println("   Ports: 443 â†’ 80");
      break;
      
    case 1:  // Port scanning attack
      data.id_orig_p = random(15000, 25000);
      data.id_resp_p = random(20, 1024);  // Scanning low ports
      data.duration = random(1, 10) / 10000.0;  // Very short duration
      data.orig_bytes = random(0, 100);
      data.resp_bytes = 0;
      data.orig_pkts = random(1, 3);
      data.resp_pkts = 0;
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = 0;
      Serial.println("   Type: ğŸš¨ Port scanning attack");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ " + String(data.id_resp_p) + " (scan)");
      break;
      
    case 2:  // DDoS attack pattern
      data.id_orig_p = random(1024, 65535);
      data.id_resp_p = 80;
      data.duration = random(1, 5) / 1000.0;  // Very short bursts
      data.orig_bytes = random(20, 100);
      data.resp_bytes = 0;
      data.orig_pkts = 1;
      data.resp_pkts = 0;
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = 0;
      Serial.println("   Type: âš¡ DDoS flood attack");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ 80 (flood)");
      break;
      
    case 3:  // Botnet C&C communication
      data.id_orig_p = random(40000, 50000);
      data.id_resp_p = random(6660, 6669);  // IRC-like ports
      data.duration = random(5, 30) / 1000.0;
      data.orig_bytes = random(200, 800);
      data.resp_bytes = random(150, 600);
      data.orig_pkts = random(3, 8);
      data.resp_pkts = random(2, 6);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("   Type: ğŸ¤– Botnet C&C communication");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ " + String(data.id_resp_p) + " (botnet)");
      break;
      
    case 4:  // Cryptocurrency mining malware
      data.id_orig_p = random(30000, 40000);
      data.id_resp_p = random(4444, 8888);  // Mining pool ports
      data.duration = random(10, 60);  // Long duration
      data.orig_bytes = random(500, 1500);
      data.resp_bytes = random(300, 1000);
      data.orig_pkts = random(5, 15);
      data.resp_pkts = random(4, 12);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("   Type: â›ï¸  Cryptocurrency mining malware");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ " + String(data.id_resp_p) + " (mining)");
      break;
      
    case 5:  // Data exfiltration
      data.id_orig_p = random(35000, 45000);
      data.id_resp_p = random(21, 25);  // FTP-like ports
      data.duration = random(2, 15);
      data.orig_bytes = random(5000, 50000);  // Large data transfer
      data.resp_bytes = random(100, 500);
      data.orig_pkts = random(20, 100);
      data.resp_pkts = random(2, 10);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("   Type: ğŸ“¤ Data exfiltration attempt");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ " + String(data.id_resp_p) + " (exfil)");
      break;
      
    case 6:  // Ransomware communication
      data.id_orig_p = random(50000, 60000);
      data.id_resp_p = random(443, 8443);  // HTTPS variants
      data.duration = random(1, 8);
      data.orig_bytes = random(800, 2000);
      data.resp_bytes = random(1000, 3000);
      data.orig_pkts = random(8, 20);
      data.resp_pkts = random(10, 25);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("   Type: ğŸ”’ Ransomware C&C traffic");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ " + String(data.id_resp_p) + " (ransom)");
      break;
      
    case 7:  // IoT malware (Mirai-like)
      data.id_orig_p = random(20000, 30000);
      data.id_resp_p = random(23, 2323);  // Telnet ports
      data.duration = random(100, 500) / 1000.0;
      data.orig_bytes = random(50, 200);
      data.resp_bytes = random(30, 150);
      data.orig_pkts = random(2, 6);
      data.resp_pkts = random(1, 4);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("   Type: ğŸŒ IoT malware (Mirai-style)");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ " + String(data.id_resp_p) + " (IoT)");
      break;
      
    case 8:  // Backdoor/RAT communication
      data.id_orig_p = random(45000, 55000);
      data.id_resp_p = random(1337, 31337);  // Common RAT ports
      data.duration = random(2, 20);
      data.orig_bytes = random(300, 1200);
      data.resp_bytes = random(400, 1500);
      data.orig_pkts = random(4, 12);
      data.resp_pkts = random(5, 15);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("   Type: ğŸšª Backdoor/RAT communication");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ " + String(data.id_resp_p) + " (RAT)");
      break;
      
    case 9:  // DNS tunneling
      data.id_orig_p = random(32000, 42000);
      data.id_resp_p = 53;  // DNS port
      data.duration = random(50, 300) / 1000.0;
      data.orig_bytes = random(100, 400);
      data.resp_bytes = random(80, 350);
      data.orig_pkts = random(2, 8);
      data.resp_pkts = random(2, 8);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("   Type: ğŸ•³ï¸  DNS tunneling attack");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ 53 (DNS tunnel)");
      break;
      
    case 10:  // Keylogger data transmission
      data.id_orig_p = random(38000, 48000);
      data.id_resp_p = random(8080, 9090);
      data.duration = random(500, 2000) / 1000.0;
      data.orig_bytes = random(200, 800);
      data.resp_bytes = random(50, 200);
      data.orig_pkts = random(3, 10);
      data.resp_pkts = random(1, 5);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("   Type: âŒ¨ï¸  Keylogger data transmission");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ " + String(data.id_resp_p) + " (keylog)");
      break;
      
    case 11:  // Normal IoT device communication (benign)
      data.id_orig_p = random(1024, 5000);
      data.id_resp_p = random(80, 443);
      data.duration = random(100, 1000) / 1000.0;
      data.orig_bytes = random(100, 1000);
      data.resp_bytes = random(50, 500);
      data.orig_pkts = random(1, 10);
      data.resp_pkts = random(1, 8);
      data.orig_ip_bytes = data.orig_bytes;
      data.resp_ip_bytes = data.resp_bytes;
      Serial.println("   Type: ğŸ  Normal IoT communication");
      Serial.println("   Ports: " + String(data.id_orig_p) + " â†’ " + String(data.id_resp_p) + " (benign)");
      break;
  }
  
  data.missed_bytes = 0;
  
  Serial.println("   Duration: " + String(data.duration, 6) + "s");
  Serial.println("   Bytes: " + String(data.orig_bytes) + " sent, " + String(data.resp_bytes) + " received");
  
  return data;
}

ThreatAnalysis analyzeTraffic(NetworkData data) {
  ThreatAnalysis result;
  result.is_malicious = false;
  result.confidence = 0.0;
  result.threat_level = "MINIMAL";
  result.recommendation = "ALLOW_NORMAL_OPERATION";
  result.error = "";
  
  Serial.println("ğŸ”— Connecting to: " + String(api_server) + api_endpoint);
  
  HTTPClient http;
  http.begin(String(api_server) + api_endpoint);
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(api_timeout);
  
  // Add User-Agent header
  http.addHeader("User-Agent", "ESP32-MalwareDetector/1.0");
  
  DynamicJsonDocument doc(1024);
  doc["id_orig_p"] = data.id_orig_p;
  doc["id_resp_p"] = data.id_resp_p;
  doc["duration"] = data.duration;
  doc["orig_bytes"] = data.orig_bytes;
  doc["resp_bytes"] = data.resp_bytes;
  doc["missed_bytes"] = data.missed_bytes;
  doc["orig_pkts"] = data.orig_pkts;
  doc["orig_ip_bytes"] = data.orig_ip_bytes;
  doc["resp_pkts"] = data.resp_pkts;
  doc["resp_ip_bytes"] = data.resp_ip_bytes;
  
  String jsonString;
  serializeJson(doc, jsonString);
  
  Serial.println("ğŸ“¤ Sending to ML API: " + jsonString);
  Serial.println("â±ï¸  Timeout set to: " + String(api_timeout) + "ms");
  
  unsigned long startTime = millis();
  int httpCode = http.POST(jsonString);
  unsigned long responseTime = millis() - startTime;
  
  Serial.println("â±ï¸  Response time: " + String(responseTime) + "ms");
  Serial.println("ğŸ”§ HTTP Response Code: " + String(httpCode));
  
  if (httpCode == 200) {
    String response = http.getString();
    Serial.println("ğŸ“¥ API Response: " + response);
    
    DynamicJsonDocument responseDoc(1024);
    deserializeJson(responseDoc, response);
    
    result.is_malicious = responseDoc["is_malicious"];
    result.confidence = responseDoc["confidence"];
    result.threat_level = responseDoc["threat_level"].as<String>();
    result.recommendation = responseDoc["recommendation"].as<String>();
    
  } else if (httpCode > 0) {
    Serial.println("âŒ HTTP Error: " + String(httpCode));
    String response = http.getString();
    if (response.length() > 0) {
      Serial.println("ğŸ“„ Error Response: " + response);
    }
    result.error = "HTTP_ERROR_" + String(httpCode);
  } else {
    Serial.println("âŒ Connection Error: " + String(httpCode));
    Serial.println("ğŸ’¡ Possible causes:");
    Serial.println("   â€¢ Server not reachable");
    Serial.println("   â€¢ Network timeout");
    Serial.println("   â€¢ WiFi connection issue");
    result.error = "CONNECTION_ERROR";
  }
  
  http.end();
  return result;
}

void handleThreatResult(ThreatAnalysis result) {
  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘      THREAT ANALYSIS RESULT            â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  
  if (result.error != "") {
    Serial.println("âŒ Error: " + result.error);
    Serial.println("ğŸ’¡ Check if server is running!");
    blinkLED(LED_STATUS, 5, 100);
    return;
  }
  
  Serial.println("ğŸ¯ Malicious:     " + String(result.is_malicious ? "âš ï¸  YES âš ï¸" : "âœ… NO"));
  Serial.println("ğŸ“Š Confidence:    " + String(result.confidence * 100, 1) + "%");
  Serial.println("âš ï¸  Threat Level:  " + result.threat_level);
  Serial.println("ğŸ’¡ Recommendation: " + result.recommendation);
  
  // Visual indication with LEDs
  if (result.is_malicious) {
    Serial.println("\nğŸš¨ğŸš¨ğŸš¨ THREAT DETECTED ğŸš¨ğŸš¨ğŸš¨");
    Serial.println("ğŸ’¡ LED: Red fast blinking (ALERT)");
    
    // Turn off safe LED, fast blink threat LED
    digitalWrite(LED_SAFE, LOW);
    for (int i = 0; i < 10; i++) {
      digitalWrite(LED_THREAT, HIGH);
      delay(100);
      digitalWrite(LED_THREAT, LOW);
      delay(100);
    }
    
    if (result.recommendation == "BLOCK_IMMEDIATELY") {
      Serial.println("ğŸ›¡ï¸  ACTION: BLOCKING CONNECTION IMMEDIATELY");
    } else if (result.recommendation == "INVESTIGATE_AND_MONITOR") {
      Serial.println("ğŸ” ACTION: INVESTIGATING AND MONITORING");
    }
    
  } else {
    Serial.println("\nâœ… Traffic appears SAFE");
    Serial.println("ğŸ’¡ LED: Green slow blink (SAFE)");
    
    // Turn off threat LED, slow blink safe LED
    digitalWrite(LED_THREAT, LOW);
    for (int i = 0; i < 3; i++) {
      digitalWrite(LED_SAFE, HIGH);
      delay(300);
      digitalWrite(LED_SAFE, LOW);
      delay(300);
    }
  }
  
  Serial.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}

void monitorNetworkActivity() {
  static unsigned long lastActivity = 0;
  
  if (millis() - lastActivity > 5000) {
    if (random(0, 100) < 10) {
      Serial.println("ğŸ“¡ Background network activity detected");
      digitalWrite(LED_STATUS, HIGH);
      delay(50);
      digitalWrite(LED_STATUS, LOW);
    }
    lastActivity = millis();
  }
}

void startupSequence() {
  Serial.println("ğŸš€ Initializing system...");
  Serial.println("ğŸ’¡ Testing all LEDs...");
  
  // Test each LED
  for (int i = 0; i < 3; i++) {
    digitalWrite(LED_SAFE, HIGH);
    delay(200);
    digitalWrite(LED_SAFE, LOW);
    digitalWrite(LED_THREAT, HIGH);
    delay(200);
    digitalWrite(LED_THREAT, LOW);
    digitalWrite(LED_STATUS, HIGH);
    delay(200);
    digitalWrite(LED_STATUS, LOW);
  }
  
  Serial.println("âœ… LED test complete");
}

void blinkLED(int pin, int times, int delayMs) {
  for (int i = 0; i < times; i++) {
    digitalWrite(pin, HIGH);
    delay(delayMs);
    digitalWrite(pin, LOW);
    delay(delayMs);
  }
}